/**************
 * CONFIG
 **************/
const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTH18JY92PQUibhQfTwhTcJZpEEuz-NrBbe4fUWAB0lSCT2tY-X9GwIVEQhr8XCHEH08EHfq3vav1Td/pub?output=csv";
const DRIVE_FOLDER_ID = "1xtjpkFnhmkmz5xAfQMvEEzGvWLyYIKrV";
const TZ = "America/Costa_Rica";

/**************
 * PUBLIC ENTRY POINTS YOU CAN RUN
 **************/
// Run this to export the latest month only.
function run_generateLatestMonth() {
  const data = loadCsvAsObjects(CSV_URL);
  const idx = buildIndex(data);
  if (!idx.latest.year) throw new Error("No dated rows in CSV.");
  const out = generateMonthPdfAndSave(
    data,
    DRIVE_FOLDER_ID,
    idx.latest.year,
    idx.latest.month
  );
  Logger.log(out);
}

// Run this to export ALL months it can find.
function run_generateAllMonths() {
  const data = loadCsvAsObjects(CSV_URL);
  const idx = buildIndex(data);
  const folder = DriveApp.getFolderById(DRIVE_FOLDER_ID);
  const results = [];
  for (const y of idx.years.sort((a,b)=>a-b)) {
    for (const m of (idx.monthsByYear[y]||[]).sort((a,b)=>a-b)) {
      results.push(generateMonthPdfAndSave(data, folder.getId(), y, m));
    }
  }
  Logger.log(results);
}

// Run this with your own y/m if needed.
function run_generateSpecificMonth() {
  const YEAR = 2024;
  const MONTH = 8; // 1-12
  const data = loadCsvAsObjects(CSV_URL);
  const out = generateMonthPdfAndSave(data, DRIVE_FOLDER_ID, YEAR, MONTH);
  Logger.log(out);
}

/**************
 * CORE
 **************/
function generateMonthPdfAndSave(rows, folderId, year, month) {
  const monthRows = rows
    .filter(r => {
      const ym = deriveYM(r);
      return ym.year === year && ym.month === month;
    })
    .sort((a,b) => (+parseTimestamp(b) || 0) - (+parseTimestamp(a) || 0));

  if (!monthRows.length) {
    throw new Error(`No rows for ${year}-${String(month).padStart(2,"0")}`);
  }

  const address = deriveAddress(rows) || "Property";
  const agg = aggregate(monthRows); // sections, photos, details, overall

  // Prepare view model for template (no client JS needed)
  const tiles = Object
    .keys(agg.sections)
    .sort((a,b) => {
      const A = agg.sections[a], B = agg.sections[b];
      if (B.fails !== A.fails) return B.fails - A.fails;
      return a.localeCompare(b);
    })
    .map(code => {
      const s = agg.sections[code];
      const pct = s.total ? Math.round((s.passes / s.total) * 100) : null;
      return {
        code,
        name: sectionName(code),
        passes: s.passes,
        fails: s.fails,
        total: s.total,
        pct
      };
    });

  const photoSections = Object
    .keys(agg.photos)
    .sort()
    .map(code => ({
      code,
      name: sectionName(code),
      items: (agg.photos[code] || [])
        .map(p => ({
          flagged: !!p.flagged,
          ts: p.ts,
          // Embed as data URL (critical so PDF has images)
          dataUrl: imageUrlToDataUrl(p.url)
        }))
    }));

  const issues = [];
  Object.keys(agg.details).forEach(code => {
    const bad = (agg.details[code] || []).filter(x => !x.pass);
    if (bad.length) {
      // group same text
      const map = {};
      bad.forEach(it => {
        const key = `${it.question} — ${String(it.answer)}`;
        map[key] = (map[key] || 0) + 1;
      });
      const items = Object.keys(map).map(k => ({ text: k, count: map[k] }));
      issues.push({ code, name: sectionName(code), items });
    }
  });
  issues.sort((a,b)=>a.name.localeCompare(b.name));

  const vm = {
    title: `Owner Inspection — ${address}`,
    headerLine: `${monthName(month)} ${year}`,
    address,
    year, month,
    tiles,
    photoSections,
    issues,
    overallPct: agg.overall.total ? Math.round(agg.overall.passes / agg.overall.total * 100) : null,
    tz: TZ
  };

  const html = renderTemplate_("Pdf", vm); // from Pdf.html file
  const pdfBlob = HtmlService.createHtmlOutput(html)
    .getAs(MimeType.PDF)
    .setName(`${address} — ${year}-${String(month).padStart(2,"0")}.pdf`);

  const file = DriveApp.getFolderById(folderId).createFile(pdfBlob);
  return {
    ok: true,
    fileId: file.getId(),
    name: file.getName(),
    link: "https://drive.google.com/file/d/" + file.getId() + "/view"
  };
}

/**************
 * TEMPLATE RENDER
 **************/
function renderTemplate_(fileName, data) {
  const t = HtmlService.createTemplateFromFile(fileName);
  Object.keys(data).forEach(k => t[k] = data[k]);
  // evaluate() runs no client JS here; we build static HTML with inline SVG & data URLs
  return t.evaluate().getContent();
}

/**************
 * CSV / DATA HELPERS
 **************/
const TS_KEYS = ['Timestamp','timestamp','Marca temporal','marca temporal','Fecha','fecha','Fecha y hora','fecha y hora','Date','Datetime','date','datetime'];
const META_HINTS = ['email','correo','name','nombre','inspector','by who','por quién','submitted','enviado'];
const PHOTO_HINTS = ['photo','photos','foto','fotos','imagen','imágenes','imagenes','image','images','picture','pictures','pic','screenshot','url','link'];
const COMMENT_HINTS = ['if you answered','si respondió','si respondiste','describe','describa','coment','comment','nota','notes','observación','observaciones','por favor','explain','explique'];
const ADDRESS_HINTS = ['address','direccion','dirección','property','propiedad','unit','apt','suite','street','calle','listing'];
const FRIENDLY = {BR:'Bedroom',BD:'Bedroom',BA:'Bathroom',KT:'Kitchen',KI:'Kitchen',LR:'Living Room',LV:'Living Room',GQ:'General',LL:'Locks & Lights',LA:'Laundry',DR:'Dining Room',EX:'Exterior',ALL:'All Checks'};

function loadCsvAsObjects(url) {
  const res = UrlFetchApp.fetch(url, { followRedirects: true, muteHttpExceptions: true });
  if (res.getResponseCode() !== 200) {
    throw new Error("HTTP " + res.getResponseCode() + " fetching CSV");
  }
  const text = sanitizeCsvText(res.getContentText() || "");
  const rows = Utilities.parseCsv(text);
  if (!rows.length) return [];
  const headers = rows[0].map(h => (h || "").toString());
  const out = [];
  for (let i = 1; i < rows.length; i++) {
    const r = {};
    const a = rows[i];
    headers.forEach((h, idx) => r[h] = (a[idx] == null ? "" : String(a[idx])));
    out.push(r);
  }
  return out;
}
function sanitizeCsvText(text) {
  if (text && text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  return text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}

function parseTimestamp(row) {
  const t = firstVal(row, TS_KEYS);
  if (t == null || t === "") return null;
  // Try standard parse first
  const d1 = new Date(t);
  if (isFinite(+d1)) return d1;
  // Try dd/mm/yyyy or mm/dd/yyyy with time
  const m = String(t).match(/^(\d{1,2})[\/-](\d{1,2})[\/-](\d{2,4})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m) {
    let a=+m[1], b=+m[2], y=+m[3]; if (y<100) y+=2000;
    const month = a>12 ? b : a;
    const day = a>12 ? a : b;
    const hh = +(m[4]||"0"), mm=+(m[5]||"0"), ss=+(m[6]||"0");
    const d = new Date(y, month-1, day, hh, mm, ss);
    if (isFinite(+d)) return d;
  }
  return null;
}
function deriveYM(row) {
  const d = parseTimestamp(row);
  return d ? { year: d.getFullYear(), month: d.getMonth()+1 } : { year: undefined, month: undefined };
}
function buildIndex(rows) {
  const years = new Set();
  const monthsByYear = {};
  let latestTs = 0, latest = { year: undefined, month: undefined };
  rows.forEach(r => {
    const d = parseTimestamp(r);
    if (!d) return;
    const y = d.getFullYear(), m = d.getMonth()+1;
    years.add(y);
    (monthsByYear[y] = monthsByYear[y] || new Set()).add(m);
    if (+d > latestTs) { latestTs = +d; latest = { year: y, month: m }; }
  });
  const outMonths = {};
  Object.keys(monthsByYear).forEach(y => outMonths[y] = Array.from(monthsByYear[y]));
  return { years: Array.from(years), monthsByYear: outMonths, latest };
}

function firstVal(row, keys) {
  for (const k of keys) {
    if (Object.prototype.hasOwnProperty.call(row, k)) {
      const v = row[k];
      if (v != null && String(v).trim() !== "") return v;
    }
  }
}

function isMetaHeader(h) {
  const l = (h||"").toLowerCase();
  return TS_KEYS.some(k => l === k.toLowerCase()) || META_HINTS.some(hint => l.indexOf(hint) >= 0);
}
function isPhotoHeader(h) {
  const s = (h||""); const l = s.toLowerCase();
  const dl = stripAccents(s).toLowerCase();
  return PHOTO_HINTS.some(hint => l.indexOf(hint) >= 0 || dl.indexOf(hint) >= 0);
}
function isCommentOnlyHeader(h) {
  const l = (h||"").toLowerCase();
  return COMMENT_HINTS.some(hint => l.indexOf(hint) >= 0);
}
function sectionKeyFromHeader(h) {
  if (!h) return null;
  const m = String(h).match(/\[([A-Za-z0-9_]+)\]/);
  if (!m) return null;
  return m[1].replace(/_.*/, "");
}
function sectionName(code) {
  if (code === "ALL") return "All Checks";
  return FRIENDLY[code] ? `${FRIENDLY[code]}${code === "ALL" ? "" : ` (${code})`}` : code;
}
function stripAccents(s) {
  return String(s||"").normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function headerTokens(h) {
  const cleaned = String(h||"")
    .replace(/\[[^\]]+\]\s*/,"")
    .replace(/\b(photos?|fotos?|imagen(?:es)?|image|images|picture|pictures|pic|screenshot|url|link)\b/gi,"")
    .replace(/[:\-–—()]/g," ");
  return stripAccents(cleaned).toLowerCase().replace(/[^a-z0-9]+/g," ").trim().split(/\s+/).filter(Boolean);
}
function classifyAnswer(val) {
  if (val == null) return "ignore";
  const raw = String(val).trim();
  if (!raw) return "ignore";
  if (/\bhttps?:\/\//i.test(raw)) return "ignore"; // URL cells are not answers
  const tokens = stripAccents(raw).toLowerCase().replace(/[^a-z]+/g," ").trim().split(/\s+/);
  const yes = new Set(["yes","si","y","affirmative","true"]);
  const no  = new Set(["no","n","negative","false"]);
  const hasYes = tokens.some(t => yes.has(t));
  const hasNo  = tokens.some(t => no.has(t));
  if (hasYes && !hasNo) return "pass";
  if (hasNo && !hasYes) return "fail";
  return "ignore";
}
function splitUrls(val) {
  let s = String(val||"").replace(/\bwww\.[^\s,;|)\]>]+/gi, m => "https://" + m);
  const out = [];
  const re = /(https?:\/\/[^\s<>"\)\],;|]+)(?=[\s<>"\)\],;|]|$)/gi;
  let m;
  while ((m = re.exec(s))) {
    let u = m[1].replace(/[\)\],;.!?]+$/,"").replace(/^http:/i,"https:");
    out.push(u);
  }
  return out;
}
function aggregate(rows) {
  const agg = { sections:{}, photos:{}, details:{}, overall:{passes:0,fails:0,total:0,rate:0} };
  const headers = rows.length ? Object.keys(rows[0]||{}) : [];
  const photoSeen = new Set();
  let sawBracket = false;

  const tokenCache = {};
  const tok = h => tokenCache[h] || (tokenCache[h] = headerTokens(h));
  const overlap = (a,b) => {
    const sb = new Set(b); let n=0; a.forEach(t=>{ if (sb.has(t)) n++; }); return n;
  };

  for (const row of rows) {
    const ts = parseTimestamp(row) || new Date();
    const rowQs = [];
    const rowPics = [];

    for (const h of headers) {
      if (isMetaHeader(h)) continue;
      const val = row[h];
      const code = sectionKeyFromHeader(h) || "ALL";
      if (sectionKeyFromHeader(h)) sawBracket = true;

      if (isPhotoHeader(h)) {
        const urls = splitUrls(val);
        if (urls.length) rowPics.push({ key: code, header: h, tokens: tok(h), urls });
        continue;
      }
      if (isCommentOnlyHeader(h)) continue;

      const cls = classifyAnswer(val);
      if (cls === "ignore") continue;

      (agg.sections[code] || (agg.sections[code] = {passes:0,fails:0,total:0}));
      (agg.details[code]  || (agg.details[code]  = []));
      agg.details[code].push({ question:h, answer:String(val), pass:(cls==='pass'), ts:ts });
      if (cls === "pass") agg.sections[code].passes++; else agg.sections[code].fails++; agg.sections[code].total++;
      rowQs.push({ key:code, header:h, tokens:tok(h), pass:(cls==='pass') });
    }

    for (const p of rowPics) {
      for (const url of p.urls) {
        if (photoSeen.has(url)) continue; photoSeen.add(url);
        // best match a question to flag issue
        let best = null, bestScore = 0;
        for (const q of rowQs) {
          const score = overlap(p.tokens, q.tokens) + (q.key === p.key ? 1 : 0);
          if (score > bestScore) { bestScore = score; best = q; }
        }
        const flagged = (best && !best.pass && bestScore > 0);
        (agg.photos[p.key] || (agg.photos[p.key] = [])).push({ url, ts, flagged });
      }
    }
  }

  if (!sawBracket && Object.keys(agg.photos).length) {
    const merged = { ALL: [] };
    Object.values(agg.photos).forEach(arr => merged.ALL.push(...arr));
    agg.photos = merged;
  }

  for (const s of Object.values(agg.sections)) {
    agg.overall.passes += s.passes;
    agg.overall.fails  += s.fails;
    agg.overall.total  += s.total;
  }
  agg.overall.rate = agg.overall.total ? (agg.overall.passes / agg.overall.total * 100) : 0;
  return agg;
}

function deriveAddress(rows) {
  if (!rows || !rows.length) return "";
  const headers = Object.keys(rows[0]||{});
  let addrCol = headers.find(h => ADDRESS_HINTS.some(hint => (h||"").toLowerCase().indexOf(hint) >= 0)) || "";
  if (!addrCol) addrCol = headers.find(h => /property|propiedad/i.test(h)) || "";
  if (addrCol) {
    for (const r of rows) {
      const v = r[addrCol];
      if (v && String(v).trim()) return String(v).trim();
    }
  }
  return "";
}

/**************
 * IMAGES → DATA URL (to embed into PDF)
 **************/
function driveIdFromUrl(u) {
  try {
    const m1 = u.match(/\/file\/d\/([^/]+)/);
    if (m1) return m1[1];
    const m2 = u.match(/[?&]id=([^&]+)/);
    if (m2) return m2[1];
  } catch(e) {}
  return null;
}
function dropboxDirect(u) {
  try {
    if (!/dropbox\.com/i.test(u)) return null;
    const mm = u.replace("www.dropbox.com","dropbox.com").match(/^https?:\/\/dropbox\.com\/s\/([^?]+)(.*)$/i);
    if (!mm) return null;
    return "https://dl.dropboxusercontent.com/s/" + mm[1];
  } catch(e) { return null; }
}
function imageUrlToDataUrl(u) {
  if (!u) return "";
  try {
    u = String(u).replace(/^http:/i, "https:");
  } catch(e) {}
  // Drive (owned or shared) – use DriveApp to get the blob, bypassing auth prompts
  const id = driveIdFromUrl(u);
  if (id) {
    try {
      const blob = DriveApp.getFileById(id).getBlob();
      const ct = blob.getContentType() || "image/jpeg";
      const b64 = Utilities.base64Encode(blob.getBytes());
      return "data:" + ct + ";base64," + b64;
    } catch(e) {
      // fall through to URL fetch if not accessible via DriveApp
    }
  }
  const db = dropboxDirect(u);
  const url = db || u;
  try {
    const resp = UrlFetchApp.fetch(url, { followRedirects: true, muteHttpExceptions: true });
    if (resp.getResponseCode() >= 200 && resp.getResponseCode() < 300) {
      let blob = resp.getBlob();
      // Normalize unknown types to jpeg so PDF renders fine
      let ct = blob.getContentType() || "image/jpeg";
      if (!/^image\//i.test(ct)) {
        blob = blob.copyBlob().setContentType("image/jpeg");
        ct = "image/jpeg";
      }
      const b64 = Utilities.base64Encode(blob.getBytes());
      return "data:" + ct + ";base64," + b64;
    }
  } catch(e) {}
  return ""; // show as empty if totally unreachable
}

/**************
 * MISC
 **************/
function monthName(m) {
  const date = new Date(2000, m-1, 1);
  return Utilities.formatDate(date, TZ, "MMMM");
}
